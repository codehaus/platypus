/***
 *  Platypus: Page Layout and Typesetting Software (free at platypus.pz.org)
 *
 *  Platypus is (c) Copyright 2006-08 Pacific Data Works LLC. All Rights Reserved.
 *  Licensed under Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html)
 */

package org.pz.platypus.parsers;

import org.pz.platypus.*;
import org.pz.platypus.exceptions.InvalidCommandException;
import org.pz.platypus.exceptions.InvalidCommandParameterException;
import org.pz.platypus.interfaces.ICommand;

/**
 * Handles parsing of compound commands
 *
 * @author alb
 */
@SuppressWarnings("unchecked")
public class CommandFamilyParser
{
    /**
     * Parses a compound command, extracting the next command (as pointed to in the ParseContext)
     * and any parameters associated with the command.
     *
     * @param ctable map of all commands
     * @param context the parsing context
     * @param parsedTokens the output list of tokens generated by the isLineComment
     * @param familyRoot the root of the command family = [font|
     * @param gdd GDD
     * @return the number of characters processsed
     *
     * @throws InvalidCommandException if the command cannot be found
     * @throws InvalidCommandParameterException if the parameter is invalid
     * @throws IllegalArgumentException if an invalid arg is passed to the method
     */
    public int parse( final CommandTable ctable,
                      final ParseContext context,
                      final TokenList parsedTokens,
                      final String familyRoot,
                      final GDD gdd )
    {
        if( gdd == null ) {
            throw new IllegalArgumentException( "GDD is null in CommandFamilyParser.parse()" );
        }
        
        if( ctable == null || parsedTokens == null || familyRoot == null ||
            context == null  )  {
            throw new IllegalArgumentException( gdd.getLit( "ERROR.INVALID_PARAMETER_NULL" ));
        }
        
        int parsePoint = context.startPoint + familyRoot.length() - 1;
        if( context.isPastEol( parsePoint ) || context.chars[parsePoint] != '|' ) {
            throw new IllegalArgumentException( gdd.getLit( "ERROR.INVALID_PARAMETER" ));
        }

        // now at the | that starts first command, so loop until all commands are processed.
        boolean paramsProcessed = false;
        while( ! paramsProcessed ) {

            final String command = extractCommandName( context.chars, ++parsePoint );

            // look up the command name in the command table
            ICommand com = ctable.getCommand( familyRoot + command );
            if( com == null ) {
                invalidCommandError( gdd, context, command );
                throw new InvalidCommandException( command );
            }

            parsePoint += command.length();

            // what type of parameter does the command take? Currently, ParamType.NONE is
            // not a supported option for family commands, but it might be in the future.
            CommandParameter param = new CommandParameter();
            if( com.getParamType() == ParamType.NONE ) {
                param.setUnit( UnitType.NONE );
            }

            // parameter is a string
            if( com.getParamType() == ParamType.STRING ) {
                param = CommandParameterParser.extractStringParam( context.chars, parsePoint );
                if( param == null ) {
                    invalidParameterError( gdd, context, com.getRoot() );
                    throw new InvalidCommandParameterException( command );
                }
                parsePoint += param.getCharsParsed();
            }

            // parameter is a number, possibly followed by a unit of measure.
            if( com.getParamType() == ParamType.NUMBER ||
                com.getParamType() == ParamType.MEASURE ) {

                param = CommandParameterParser.extractUnitValue( context.chars, parsePoint );
                if( param == null || param.getErrorCode() != Status.OK ) {
                    invalidParameterError( gdd, context, command );
                    throw new InvalidCommandParameterException( command );
                }
                parsePoint += param.getCharsParsed();
            }

            if( com.getParamType() == ParamType.MEASURE ) {
                param.setUnit( CommandParameterParser.extractUnitType( context.chars, parsePoint ));
                if( param.getUnit() == UnitType.ERROR ) {
                    invalidParameterError( gdd, context, command );
                    throw new InvalidCommandParameterException( command );
                }

                if( param.getUnit() != UnitType.NONE ) {
                    param.setCharsParsed( param.getCharsParsed() + 2 );
                    parsePoint += 2;
                }
            }

            parsedTokens.add( new Token( context.source, TokenType.COMMAND,
                              familyRoot + command, null, param ));

            // parsePoint now points to the first char after the processed parameter
            // TODO: make sure it's a legitimate value before dereferencing it
            if(( context.chars[parsePoint] == ']' ) ||
               ( com.getParamType() == ParamType.NONE && context.chars[parsePoint-1] == ']')) {
                paramsProcessed = true;
            }
        }

        fixUp( parsedTokens, context, parsePoint );
        return( parsePoint - context.startPoint + 1 );
    }

    /**
     * Complex commands can have 1 or more commands. If it's just 1, this routine converts
     * it into a simple command. Otherwise, it's a complex command and the opening and closing
     * tokens are added to the token list.
     * @param tokens list of parsed commands
     * @param context the parser context
     * @param end  the end point in the input
     */
    void fixUp( TokenList tokens, final ParseContext context, int end )
    {
        if( tokens == null || tokens.size() < 1 || context == null || context.isPastEol( end )) {
            return;
        }

        Token t = tokens.get( 0 );
        String lexeme = context.segment( end + 1 );

        // if it's just one token, then add the lexeme to the token.content field.
        if( tokens.size() == 1 ) {
            t.setContent( lexeme );
            tokens.add( t );
            tokens.remove( 0 );
        }
        else {
        // otherwise add the beginning and ending tokens for a compound command.
            Token newTok = new Token( t.getSource(), TokenType.COMPOUND_COMMAND, t.getRoot(),
                        lexeme, null );
            tokens.add( 0, newTok );

            newTok = new Token( t.getSource(),
                        TokenType.COMPOUND_COMMAND_END, t.getRoot(), null, null );
            tokens.add( tokens.size(), newTok );
        }
    }

    /**
     * return a command name in a complex command; e.g. "size" in [font|size=12pt]
     * @param content the input we're parsing
     * @param parsePoint where to start the isLineComment
     * @return a string consisting of the command, or null on error.
     */
    String extractCommandName( final char[] content, int parsePoint )
    {
        if ( content == null || parsePoint < 0 ) {
            return( null );
        }

        StringBuilder sb = new StringBuilder( content.length - parsePoint );
        for( int i = parsePoint; i < content.length; i++ )
        {
            sb.append( content[i] );
            if(  content[i] == '|' || content[i] == ':' || content[i] == ']' ) {
                    break;
            }
        }
        return( sb.toString() );
    }

    /**
     * Outputs the error info to the user console
     *
     * @param gdd the GDD, used for the logger
     * @param context where the error occurred
     * @param command the errant command
     */
    private void invalidCommandError( final GDD gdd,
                                      final ParseContext context, final String command )
    {
        final String badCommand = command == null? "(null)" : command;

        gdd.logWarning( gdd.getLit( "FILE#" ) + " " + context.source.getFileNumber() + " " +
                        gdd.getLit( "LINE#" ) + " " + context.source.getLineNumber() + " " +
                        gdd.getLit( "ERROR.INVALID_COMMAND" ) + " " + badCommand + " " +
                        gdd.getLit( "COMMAND_IGNORED" ));
    }

    /**
     * Outputs the error info to the user console
     *
     * @param gdd the GDD, used for the logger
     * @param context where the error occurred
     * @param command the command withe the errant parameter
     */
    private void invalidParameterError( final GDD gdd,
                                        final ParseContext context, final String command )
    {
        final String badCommand = command == null? "(null)" : command;

        gdd.logWarning(
                gdd.getLit( "FILE#" ) + " " + context.source.getFileNumber() + " " +
                gdd.getLit( "LINE#" ) + " " + context.source.getLineNumber() + " " +
                gdd.getLit( "ERROR.INVALID_COMMAND_PARAMETER" ) + " " +
                gdd.getLit( "COMMAND_COLON" ) + " " + badCommand + " " +
                gdd.getLit( "COMMAND_IGNORED" ));
    }
}